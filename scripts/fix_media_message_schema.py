#!/usr/bin/env python3
"""
Script to update the models and API code to use the new message_media association table.
This modifies the SQLAlchemy models to reflect the new schema.
"""

import sys
import logging
import re
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Path to models.py file
MODELS_PATH = Path("/Users/tem/archive/carchive/src/carchive/database/models.py")
SCHEMAS_PATH = Path("/Users/tem/archive/carchive/src/carchive/api/schemas.py")
CONVERSATIONS_API_PATH = Path("/Users/tem/archive/carchive/src/carchive/api/routes/conversations.py")

# Simple script to manually update the necessary files
import os

def create_models():
    """Create updated model files directly"""
    models_content = '''# src/carchive/database/models.py

import uuid
from sqlalchemy import Column, String, DateTime, ForeignKey, Text, Integer, Boolean
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship, declarative_base
from sqlalchemy.sql import func
from pgvector.sqlalchemy import Vector

# Create the base class for SQLAlchemy models
Base = declarative_base()

class Conversation(Base):
    """Represents a conversation thread."""
    __tablename__ = "conversations"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    title = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    meta_info = Column(JSONB, nullable=True)  # Metadata stored as JSONB for flexibility

    # Relationship to messages
    messages = relationship("Message", back_populates="conversation")

class Message(Base):
    """Represents a single message in a conversation."""
    __tablename__ = "messages"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    conversation_id = Column(UUID(as_uuid=True), ForeignKey("conversations.id"))
    content = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    meta_info = Column(JSONB, nullable=True)
    # Legacy field, kept for backward compatibility
    media_id = Column(UUID(as_uuid=True), ForeignKey("media.id"), nullable=True)

    # Relationships
    conversation = relationship("Conversation", back_populates="messages")
    media_associations = relationship("MessageMedia", back_populates="message")
    media_items = relationship("Media", secondary="message_media")
    chunks = relationship("Chunk", back_populates="message")

class Chunk(Base):
    """Represents a chunk of a message for processing (e.g., embeddings)."""
    __tablename__ = "chunks"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    message_id = Column(UUID(as_uuid=True), ForeignKey("messages.id"))
    content = Column(Text, nullable=True)
    position = Column(Integer, default=0)  # Order of chunks within a message
    meta_info = Column(JSONB, nullable=True)

    # Relationship
    message = relationship("Message", back_populates="chunks")

class Media(Base):
    """Represents media files associated with messages."""
    __tablename__ = "media"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    file_path = Column(String, nullable=False)  # Path to the stored media file
    media_type = Column(String, nullable=False)  # e.g., 'image', 'pdf', 'audio'
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    original_file_id = Column(String, nullable=True, index=True)  # The ID from file-XXXX
    file_name = Column(String, nullable=True)  # Original file name 
    source_url = Column(String, nullable=True)  # URL for remote files or local reference
    is_generated = Column(Boolean, default=False)  # Whether this was generated by AI

    # Relationships for the message-media association
    message_associations = relationship("MessageMedia", back_populates="media")
    messages = relationship("Message", secondary="message_media")
    
class MessageMedia(Base):
    """Links messages to media items with association type."""
    __tablename__ = "message_media"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    message_id = Column(UUID(as_uuid=True), ForeignKey("messages.id", ondelete="CASCADE"), nullable=False)
    media_id = Column(UUID(as_uuid=True), ForeignKey("media.id", ondelete="CASCADE"), nullable=False)
    association_type = Column(String, nullable=True)  # 'uploaded', 'generated', etc.
    
    # Relationships
    message = relationship("Message", back_populates="media_associations")
    media = relationship("Media", back_populates="message_associations")

class Embedding(Base):
    """Stores vector embeddings for messages or chunks."""
    __tablename__ = "embeddings"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    model_name = Column(String, nullable=False)  # e.g., 'bert', 'openai'
    model_version = Column(String, nullable=True)
    dimensions = Column(Integer, nullable=False)  # Embedding dimension
    vector = Column(Vector(768))  # Adjust dimension based on model (e.g., 768 for BERT)
    parent_message_id = Column(UUID(as_uuid=True), ForeignKey("messages.id"), nullable=True)
    parent_chunk_id = Column(UUID(as_uuid=True), ForeignKey("chunks.id"), nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    meta_info = Column(JSONB, nullable=True)

class Collection(Base):
    """Represents a collection of conversations, messages, or chunks."""
    __tablename__ = "collections"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    meta_info = Column(JSONB, nullable=True)

    # Relationship
    items = relationship("CollectionItem", back_populates="collection")

class CollectionItem(Base):
    """Links items (conversations, messages, chunks) to collections."""
    __tablename__ = "collection_items"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    collection_id = Column(UUID(as_uuid=True), ForeignKey("collections.id"))
    conversation_id = Column(UUID(as_uuid=True), ForeignKey("conversations.id"), nullable=True)
    message_id = Column(UUID(as_uuid=True), ForeignKey("messages.id"), nullable=True)
    chunk_id = Column(UUID(as_uuid=True), ForeignKey("chunks.id"), nullable=True)
    meta_info = Column(JSONB, nullable=True)

    # Relationship
    collection = relationship("Collection", back_populates="items")

class AgentOutput(Base):
    """Stores outputs from agent (e.g., LLM) processing."""
    __tablename__ = "agent_outputs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    target_type = Column(String, nullable=False)  # e.g., 'message', 'conversation', 'chunk'
    target_id = Column(UUID(as_uuid=True), nullable=False)  # ID of the target
    output_type = Column(String, nullable=False)  # e.g., 'summary', 'review'
    content = Column(Text, nullable=False)  # The generated output
    agent_name = Column(String, nullable=False)  # e.g., 'llama3.2'
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
'''

    # Write the updated models.py file
    with open(MODELS_PATH, 'w') as f:
        f.write(models_content)
    
    return True

def create_conversation_route():
    """Create updated conversation route files directly"""
    conversation_content = '''"""
API endpoints for conversations.
"""

from typing import Dict, List, Optional, Any
from uuid import UUID
from flask import Blueprint, request, jsonify, send_file, url_for
from sqlalchemy import desc, func, cast
from sqlalchemy.orm import joinedload, Session

from carchive.database.models import Conversation, Message, Media, MessageMedia
from carchive.api.schemas import ConversationBase, ConversationDetail, MessageDetail, MediaBase
from carchive.api.routes.utils import (
    db_session, validate_uuid, parse_pagination_params, 
    paginate_query, error_response
)

bp = Blueprint('conversations', __name__, url_prefix='/api/conversations')


@bp.route('/', methods=['GET'])
@db_session
def get_conversations(session: Session):
    """Get a list of conversations with pagination."""
    page, per_page = parse_pagination_params()
    
    # Get query filters
    title_filter = request.args.get('title')
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    sort_by = request.args.get('sort', 'created_at')
    sort_order = request.args.get('order', 'desc')
    
    # Build query
    query = session.query(Conversation)
    
    # Apply filters
    if title_filter:
        query = query.filter(Conversation.title.ilike(f'%{title_filter}%'))
    if start_date:
        query = query.filter(Conversation.created_at >= start_date)
    if end_date:
        query = query.filter(Conversation.created_at <= end_date)
    
    # Apply sorting
    if sort_order.lower() == 'asc':
        query = query.order_by(getattr(Conversation, sort_by))
    else:
        query = query.order_by(desc(getattr(Conversation, sort_by)))
    
    # Get message counts
    message_counts = session.query(
        Message.conversation_id,
        func.count(Message.id).label('count')
    ).group_by(Message.conversation_id).all()
    message_count_dict = {str(cid): count for cid, count in message_counts}
    
    # Get media counts per conversation
    media_count_query = session.query(
        Message.conversation_id,
        func.count(MessageMedia.media_id.distinct()).label('media_count')
    ).join(
        MessageMedia, MessageMedia.message_id == Message.id
    ).group_by(
        Message.conversation_id
    ).all()
    media_count_dict = {str(cid): count for cid, count in media_count_query}
    
    # Paginate results
    conversations, total = paginate_query(query, page, per_page)
    
    # Format response
    result = {
        'conversations': [
            {
                **ConversationBase.from_orm(conv).dict(),
                'message_count': message_count_dict.get(str(conv.id), 0),
                'media_count': media_count_dict.get(str(conv.id), 0)
            }
            for conv in conversations
        ],
        'pagination': {
            'page': page,
            'per_page': per_page,
            'total': total,
            'pages': (total + per_page - 1) // per_page
        }
    }
    
    return jsonify(result)


@bp.route('/<conversation_id>', methods=['GET'])
@db_session
def get_conversation(conversation_id: str, session: Session):
    """Get a single conversation by ID with its messages."""
    if not validate_uuid(conversation_id):
        return error_response(400, "Invalid conversation ID format")
    
    # Get include_messages parameter
    include_messages = request.args.get('include_messages', 'true').lower() == 'true'
    
    # Get conversation
    conversation = session.query(Conversation).filter(Conversation.id == conversation_id).first()
    
    if not conversation:
        return error_response(404, "Conversation not found")
    
    # Prepare response
    result = ConversationBase.from_orm(conversation).dict()
    
    # Include message count
    message_count = session.query(func.count(Message.id)).filter(
        Message.conversation_id == conversation.id
    ).scalar()
    result['message_count'] = message_count
    
    # Include media count
    media_count = session.query(func.count(MessageMedia.media_id.distinct())).join(
        Message, Message.id == MessageMedia.message_id
    ).filter(
        Message.conversation_id == conversation.id
    ).scalar()
    result['media_count'] = media_count
    
    # Include messages if requested
    if include_messages:
        # Get pagination parameters
        page, per_page = parse_pagination_params()
        
        # Query messages 
        query = session.query(Message).filter(
            Message.conversation_id == conversation.id
        ).order_by(Message.created_at)
        
        # Paginate messages
        messages, _ = paginate_query(query, page, per_page)
        
        # Get media for each message
        media_by_message = {}
        message_ids = [str(msg.id) for msg in messages]
        
        if message_ids:
            # Query media items associated with these messages
            media_query = session.query(
                MessageMedia.message_id,
                Media
            ).join(
                Media, Media.id == MessageMedia.media_id
            ).filter(
                MessageMedia.message_id.in_([UUID(mid) for mid in message_ids])
            ).all()
            
            # Group media by message_id
            for message_id, media in media_query:
                if str(message_id) not in media_by_message:
                    media_by_message[str(message_id)] = []
                media_by_message[str(message_id)].append(media)
        
        # Format messages with their media items
        result['messages'] = [
            {
                **MessageDetail.from_orm(msg).dict(),
                'media_items': [
                    {
                        'id': str(media.id),
                        'file_path': media.file_path,
                        'media_type': media.media_type,
                        'created_at': media.created_at.isoformat() if media.created_at else None,
                        'file_name': media.file_name,
                        'original_file_id': media.original_file_id,
                        'is_generated': media.is_generated
                    } for media in media_by_message.get(str(msg.id), [])
                ]
            }
            for msg in messages
        ]
        
        # Add pagination info for messages
        result['pagination'] = {
            'page': page,
            'per_page': per_page,
            'total': message_count,
            'pages': (message_count + per_page - 1) // per_page
        }
    
    return jsonify(result)


@bp.route('/<conversation_id>/summary', methods=['GET'])
@db_session
def get_conversation_summary(conversation_id: str, session: Session):
    """Get a summary of a conversation."""
    if not validate_uuid(conversation_id):
        return error_response(400, "Invalid conversation ID format")
    
    # Get conversation
    conversation = session.query(Conversation).filter(Conversation.id == conversation_id).first()
    
    if not conversation:
        return error_response(404, "Conversation not found")
    
    # Get summary from meta_info if available
    summary = None
    if conversation.meta_info and 'summary' in conversation.meta_info:
        summary = conversation.meta_info['summary']
    
    # If no summary, check if there's an agent output with a summary
    if not summary:
        # TODO: Add code to retrieve summary from AgentOutput if available
        pass
    
    return jsonify({
        'conversation_id': str(conversation.id),
        'title': conversation.title,
        'summary': summary or "No summary available"
    })
'''

    # Write the updated conversations.py file
    with open(CONVERSATIONS_API_PATH, 'w') as f:
        f.write(conversation_content)
    
    return True

def update_schemas():
    """Update the API schemas to include media_items"""
    try:
        # Read the current schemas file
        with open(SCHEMAS_PATH, "r") as file:
            content = file.read()
        
        # Check if we need to update MessageDetail
        if "MediaBase" in content and "media_items: Optional[List[MediaBase]]" not in content:
            # Find the MessageDetail class
            message_schema_pattern = r'class MessageDetail\(.*?\):\s*.*?pass'
            message_schema_match = re.search(message_schema_pattern, content, re.DOTALL)
            
            if message_schema_match:
                message_schema = message_schema_match.group(0)
                # Add media_items field before the last line
                updated_message_schema = message_schema.replace("pass", "    media_items: Optional[List[MediaBase]] = None\n    pass")
                # Replace in the content
                content = content.replace(message_schema, updated_message_schema)
                
                # Update imports if needed
                if "from typing import List, Optional, Dict, Any" in content:
                    # Import exists, no need to modify
                    pass
                else:
                    # Add List to imports
                    content = content.replace("from typing import Optional, Dict, Any", "from typing import List, Optional, Dict, Any")
                
                # Write the updated content
                with open(SCHEMAS_PATH, "w") as file:
                    file.write(content)
                
                return True
        
        return True  # Already up to date
        
    except Exception as e:
        print(f"An error occurred updating schemas: {str(e)}")
        return False

def update_models():
    """Update all model files"""
    try:
        if create_models() and create_conversation_route() and update_schemas():
            print("All model files updated successfully!")
            return True
        return False
    except Exception as e:
        print(f"Error updating models: {str(e)}")
        return False
        
        # Replace the models
        content = re.sub(r'class Message\(Base\):.*?chunks = relationship\("Chunk", back_populates="message"\)', 
                         message_model_updated, content, flags=re.DOTALL)
        
        content = re.sub(r'class Media\(Base\):.*?linked_messages = relationship\("Message", foreign_keys=\[linked_message_id\], backref="referenced_media"\)', 
                         media_model_updated, content, flags=re.DOTALL)
        
        # Add the MessageMedia model before the Embedding class
        content = content.replace("class Embedding(Base):", f"{message_media_model}\nclass Embedding(Base):")
        
        # Write the updated content back to the file
        with open(MODELS_PATH, "w") as file:
            file.write(content)
        
        logger.info("Models updated successfully!")
        return True
        
    except Exception as e:
        logger.error(f"An error occurred while updating models: {str(e)}")
        return False

def update_api_schemas():
    """Update the API schemas to use the new message_media association."""
    try:
        # Read the current schemas file
        with open(SCHEMAS_PATH, "r") as file:
            content = file.read()
        
        # Update MessageDetail to include media_items
        if "media_items: Optional[List[MediaBase]]" not in content:
            # Find the MessageDetail class
            message_schema_pattern = r'class MessageDetail\(.*?\):\s*.*?pass'
            message_schema = re.search(message_schema_pattern, content, re.DOTALL).group(0)
            
            # Add media_items field before the last line
            updated_message_schema = message_schema.replace("pass", "    media_items: Optional[List[MediaBase]] = None\n    pass")
            
            # Replace in the content
            content = content.replace(message_schema, updated_message_schema)
            
            # Write the updated content
            with open(SCHEMAS_PATH, "w") as file:
                file.write(content)
        
        logger.info("API schemas updated successfully!")
        return True
        
    except Exception as e:
        logger.error(f"An error occurred while updating API schemas: {str(e)}")
        return False

def update_conversations_api():
    """Update the conversations API to load media items through the association table."""
    try:
        # Read the current file
        with open(CONVERSATIONS_API_PATH, "r") as file:
            content = file.read()
        
        # Make sure necessary imports are present
        if "from sqlalchemy.orm import joinedload, Session" in content:
            # Update the get_conversation function to load media items
            get_conv_pattern = r'def get_conversation\(conversation_id:.*?return jsonify\(result\)'
            get_conv_func = re.search(get_conv_pattern, content, re.DOTALL).group(0)
            
            # Update the media loading logic
            if "media_items = []" not in get_conv_func:
                # Update the query to load media through the association
                updated_func = get_conv_func.replace(
                    "# Format messages",
                    """# Get media for each message
        media_by_message = {}
        message_ids = [msg.id for msg in messages]
        
        if message_ids:
            # Query media items associated with these messages
            media_query = session.query(Media).join(
                MessageMedia, MessageMedia.media_id == Media.id
            ).filter(
                MessageMedia.message_id.in_(message_ids)
            ).all()
            
            # Group media by message_id
            for media in media_query:
                for assoc in media.message_associations:
                    if str(assoc.message_id) in message_ids:
                        if str(assoc.message_id) not in media_by_message:
                            media_by_message[str(assoc.message_id)] = []
                        media_by_message[str(assoc.message_id)].append(media)
        
        # Format messages"""
                )
                
                # Update the message formatting to include media items
                updated_func = updated_func.replace(
                    "result['messages'] = [",
                    """result['messages'] = [
            {
                **MessageDetail.from_orm(msg).dict(),
                'media_items': [
                    {
                        'id': str(media.id),
                        'file_path': media.file_path,
                        'media_type': media.media_type,
                        'created_at': media.created_at.isoformat() if media.created_at else None,
                        'file_name': media.file_name,
                        'original_file_id': media.original_file_id,
                        'is_generated': media.is_generated
                    } for media in media_by_message.get(str(msg.id), [])
                ]
            }"""
                )
                
                # Replace in the content
                content = content.replace(get_conv_func, updated_func)
                
                # Make sure we import the MessageMedia model
                if "from carchive.database.models import Conversation, Message, Media" in content:
                    content = content.replace(
                        "from carchive.database.models import Conversation, Message, Media",
                        "from carchive.database.models import Conversation, Message, Media, MessageMedia"
                    )
                
                # Write the updated content
                with open(CONVERSATIONS_API_PATH, "w") as file:
                    file.write(content)
        
        logger.info("Conversations API updated successfully!")
        return True
        
    except Exception as e:
        logger.error(f"An error occurred while updating conversations API: {str(e)}")
        return False

if __name__ == "__main__":
    success = True
    
    if not update_models():
        logger.error("Failed to update models.")
        success = False
    
    if not update_api_schemas():
        logger.error("Failed to update API schemas.")
        success = False
    
    if not update_conversations_api():
        logger.error("Failed to update conversations API.")
        success = False
    
    if success:
        logger.info("All updates completed successfully!")
    else:
        logger.error("Some updates failed. See log for details.")
        sys.exit(1)